% Latex -template for writing Nomovok Documents
% Places outside of the regular text (headers etc.)
% that need to be edited are marked with comments
% beginning with 'EDIT'

\documentclass[a4paper,11pt]{article}

% First we need to include quite a bit of packages

% Use UTF-8 
\usepackage{ucs}
\usepackage[utf8x]{inputenc}

% Set font to Helvetica
% This is different from the .odt where
% Arial is used, but Arial and Helvetica
% are almost identical, for further info:
% http://www.ms-studio.com/articles.html
\usepackage[T1]{fontenc}
\usepackage{helvet}
\renewcommand*\familydefault{\sfdefault}

% To allow proper header/footer
\usepackage{fancyhdr}

% Set margins and page size
\usepackage[left=2cm,right=1cm,bottom=3.5cm,top = 2.3cm,a4paper]{geometry}

% Use the fancy header
\pagestyle{fancy}

% To obtain last page number
\usepackage{lastpage}

% For control over the output of date/time
\usepackage{datetime}

% Creation of a custom time output format
\renewcommand{\dateseparator}{.}
\newcommand{\todayiso}{\twodigit\day\dateseparator\twodigit\month\dateseparator\the\year}

% Allow insertion of figures into the document
\usepackage{graphicx}

% Allow setting of spacing for ex. table of contents
\usepackage{setspace}

% Recognize urls and pdf -links,
% breaklinks breaks the usual connections from
% TOC to chapters, this can be removed if needed
% EDIT: Here is defined the pdf -metadata.
\usepackage[breaklinks,pdftex,
  pdfauthor={Kevin Rogovin},
  pdftitle={Architecture Concept},
  pdfsubject={Events and Rendering UIs}]{hyperref}
\usepackage{html}   %  *always* load this for LaTeX2HTML


% Next we create the Nomovok -header, here we need some
% fancywork

% Erase old header and footer
\fancyhead{}
\fancyfoot{}
% Creation of the Nomovok header
\fancyhead[C]{
  % Remove cell padding from this tabular
  % 6pt (2.12mm) is the regular cell padding
  \addtolength{\tabcolsep}{-6pt}
  {\small
  \begin{tabular}{@{}l@{}@{}l@{}l@{}r@{}}
    % Row 1, with Logo
    \includegraphics[width=4.1cm]{nomovok_logo_large}&
    &  & \thepage (\pageref{LastPage}) \\    
    % Row 2
    % EDIT as needed
    N/MOBU & Architecture Concept & DRAFT &\\
    % Row 3
    % EDIT as needed
    \parbox[T]{3.8cm}{CONFIDENTIAL} & Events and Rendering UIs & \todayiso &\\
    % A phantom row to match that in the .odt -version, used here to
    % set the column widths to match those in the .odt
    \multicolumn{1}{p{4.47cm}}{} & 
    \multicolumn{1}{p{6.5cm}}{} & 
    \multicolumn{1}{p{3.84cm}}{} & 
    \multicolumn{1}{p{3.10cm}}{}\\
  \end{tabular}
  }
}

\fancyfoot{
	\centering
	\small
The contents of this document are Copyright \copyright~Nomovok Ltd. 2011.
}

% Some more setup for the document
\addtolength{\headsep}{-0.5cm}
\setlength{\headheight}{75pt}

% Set header to not have a visible line
\renewcommand{\headrulewidth}{0.0pt}

% Set baselineskip to be one and a half line
\renewcommand{\baselinestretch}{1.5}

% Setting up hyperref colorings
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black}

%Create own custom environment for indenting plain text:
\def\indenter#1{\list{}{\leftmargin#1}\item[]}
\let\endindenter=\endlist


% This fixes pdflatex page size, without breaking normal latex usage
% possibly not needed, but it never hurts to be sure.
\usepackage{ifpdf}
\ifpdf
\setlength{\pdfpagewidth}{210mm}
\setlength{\pdfpageheight}{297mm}
\else
\fi

\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black}

\begin{document}
%\begin{titlepage}
\begin{center}

% Let's align the Title vertically
\vspace*{105.5pt}
% EDIT here the heading and type of document
{\LARGE \bf Events and Rendering UIs	}\\
{\LARGE \bf Architecture Concept}\\
\vspace{71pt}

% Creation of the title-page table
% EDIT here the needed information
{
\setstretch{1.3}
\begin{tabular}{lll}
  &Document Code: & PAGE-131600 \\ 
  &Version: & 0.2 \\ 
  &Date: & \todayiso \\ 
  &Author: & Kevin Rogovin \\ 
  &Owner: & Juha Hytönen \\ 
  &Approver: & - \\
  % Again fix the widths to those in the .odt
  \multicolumn{1}{p{3.83cm}}{} &
  \multicolumn{1}{p{4.17cm}}{} & 
  \multicolumn{1}{p{8.00cm}}{}\\
\end{tabular}
}

\small
This document and its contents are considered as confidential and are to be distributed only to Nomovok, Aisin AW and limited Renesas personnel. 
Any unauthorized review, use, disclosure or distribution is prohibited. 

\end{center}

\newpage

\noindent\textbf{Change History:}
\label{sec:changelog}
\begin{table}[h!tbp]
  \begin{tabular}{rllll}
    \multicolumn{1}{c}{\textbf{\textit{Version:}}}& 
    \multicolumn{1}{c}{\textbf{\textit{Date:}}} & 
    \multicolumn{1}{c}{\textbf{\textit{Author:}}} &
    \multicolumn{1}{c}{\textbf{\textit{Status:}}} &
    \multicolumn{1}{c}{\textbf{\textit{Changes made:}}}\\
    % EDIT: Insert own lines here as version changes
    0.1 & 2011-09-08 & Kevin Rogovin & DRAFT & Initial version \\
    0.1 & 2011-10-04 & Juha Hytönen & DRAFT & Documentization \\
    %This is just for proper widths to the tabular
    \multicolumn{1}{p{1.8cm}}{}&
    \multicolumn{1}{p{2.18cm}}{}&
    \multicolumn{1}{p{3.42cm}}{}&
    \multicolumn{1}{p{2.31cm}}{}&
    \multicolumn{1}{p{6.2cm}}{}\\
  \end{tabular}
\end{table}

\newpage

% Use the same name for contents as .odt
\renewcommand{\contentsname}{Table of Contents}
% Create TOC
{
\singlespacing
\tableofcontents
}

\setlength{\parindent}{0pt}

\newpage
% EDIT: Okay, and now starts the actual body of the document.

\section{Problem Definition}
\begin{indenter}{2cm}

The purpose of this document is to illuminate a number issues with
respect to application responsiveness, event handling and rendering.

\end{indenter}
\subsection{Observations}
\begin{indenter}{2cm}

We begin with a number of observations.
\begin{enumerate}
\item In an ideal world, a user interface renders at 50-60Hz 
(i.e. 16.67-20 ms per frame). That is ideal. On performance
constrained devices we are often happy just to reach 30Hz
(33.33ms)
\item For a great deal number of GPU solutions, the time consuming step
occurs when an application says the "frame is ready", i.e. at \textit{eglSwapBuffers()}.
Indeed, for any tiled based GPU (including PowerVR SGX and ARM Mali) the
actual rasterization of primitives occurs at  \textit{eglSwapBuffers()}. This function
blocks until rasterization is completed.
\item Typically,  \textit{eglSwapBuffers()} is where the GPU is busy, not the CPU.
\item Even in non-tiled rendering strategies, the call of  \textit{eglSwapBuffers()}
may block for other reasons, for example in a double buffered solution,
the "other buffer" cannot be handed back to the application until the 
compositor signals that it is done using it.
\item User events are queued, thus even if events and rendering are handled
within the same thread of an application, if an application is busy rendering, 
user events are NOT lost. Rather they are queued in the order they are
received.
\item An application may be responsible to launch other applications from
a user event (such as a user touches a particular button).
\item An application may need to be frame limited, i.e. to conserve power,
an application may need to have it's GPU and/or CPU consumption limited.
\end{enumerate}

\end{indenter}
\subsection{Comments}
\begin{indenter}{2cm}

Before we begin, some comments.
\begin{itemize}
\item Issue (4) can be handled via a triple buffering solution outlined in  
the document \textit{Tri-Buffer Rendering - Architecture Concept}.
\item In regards to issue (7) and GPU consumption, an application only needs
to redraw itself if the content it is to display has changed. The catch
here is that if an application has animated content then it will typically
attempt to update as fast as possible. A system could have that \textit{eglSwapBuffers()}
blocks "extra" (for example 2-4 v-syncs) to prevent an application from
using a great deal of GPU power, but additional logic is required to 
"stop the block" when the application receives events. Additionally with 
regards to power management, an application should never, ever refresh faster
than the vsync (this is because it will make the chips run hot without any benefit for the user, \footnote{Slides 15-17 of
http://bps11.idav.ucdavis.edu/talks/03-powerOf3DRendering-BPS2011-koduri.pdf}.
\item In Qt, an application is told it needs to render by receiving a \textit{QPaintEvent},
hence for Qt based applications, as of now, rendering and event handling
occur on the same thread and block each other.
\item More and more SoC's for embedded devices are atleast dual-core CPU, 
currently the mid to high end SoC's are dual core with the next generation 
looking that we are going to see the high end with 4 core CPU's.
\item These extra cores are traditionally NOT used in Qt applications. However,
Qt SceneGraph runs the animation and logic in a separate thread than
the rendering/event-handling thread. It does this so that animations can
be smoother. However, the actual handling of events is still blocked
by rendering. One can anticipate that the effect of an event is seen
one to two frame after the event: an apparent response time of 16-33ms
\textbf{atleast}. It is more complicated as the events need to be fed into 
the logic thread as well (with the potential required locking). 
\end{itemize}

\end{indenter}
\section{The Solution}
\begin{indenter}{2cm}

My ideal solution is the following: for an application to have two threads:

\begin{itemize}
\item The first thread is dedicated only to rendering content: no logic, no event
handling, only rendering. Such a thread will need to perform extrapolation
to keep animations smooth and jump free. As a side note, this is what almost all
professional grade games do on PC and consoles. 
\item The second thread is the thread that receives events and runs the simulation.
The second thread will send a signal to the first thread whenever it indicates
that the rendered contents has changed. This signal will also trigger a copy
of the \textbf{minimal} amount of data from the logic thread to the rendering thread
so that the rendering thread can render the data. Likely such data will mean:
    \begin{itemize}
    \item transformation data 
    \item "speed data" so that rendering thread can extrapolate
    \item lists of created and destroyed objects.
    \item state updates that affect objects presentation
    \end{itemize}
As a side note, using the same triple buffering approach as found the document \textit{Tri-Buffer Rendering - Architecture Concept} but applied to rendering data, 
one can make the lock between the rendering and logic thread only a 
lock on 3 integers.
\end{itemize}

The advantages to such a system is that the logic will handle events as soon as possible,
additionally, an application can choose when to "flush" to the rendering thread, i.e.
rather than signal an update at every event, first empty the event queue, then flush,
or possibly in the case of lots of events, flush after so many events have been handled.

Additionally, in the case of animated content which requires constant updates,
the logic can run at a \textbf{LOWER} framerate than the rendering if the rendering thread
has extrapolation code (which again is common for games, particular multi-player client-sever 
games, such code is not new technique, dating back atleast to 1999 in Quake3). One may
wish for the logic to run at a lower rate if it is CPU intensive.

\end{indenter}
\end{document}
