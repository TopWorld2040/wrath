% Latex -template for writing Nomovok Documents
% Places outside of the regular text (headers etc.)
% that need to be edited are marked with comments
% beginning with 'EDIT'

\documentclass[a4paper,11pt]{article}

% First we need to include quite a bit of packages

% Use UTF-8 
\usepackage{ucs}
\usepackage[utf8x]{inputenc}

% Set font to Helvetica
% This is different from the .odt where
% Arial is used, but Arial and Helvetica
% are almost identical, for further info:
% http://www.ms-studio.com/articles.html
\usepackage[T1]{fontenc}
\usepackage{helvet}
\renewcommand*\familydefault{\sfdefault}

% To allow proper header/footer
\usepackage{fancyhdr}

% Set margins and page size
\usepackage[left=2cm,right=1cm,bottom=3.5cm,top = 2.3cm,a4paper]{geometry}

% Use the fancy header
\pagestyle{fancy}

% To obtain last page number
\usepackage{lastpage}

% For control over the output of date/time
\usepackage{datetime}

% Creation of a custom time output format
\renewcommand{\dateseparator}{.}
\newcommand{\todayiso}{\twodigit\day\dateseparator\twodigit\month\dateseparator\the\year}

% Allow insertion of figures into the document
\usepackage{graphicx}

% Allow setting of spacing for ex. table of contents
\usepackage{setspace}

% Recognize urls and pdf -links,
% breaklinks breaks the usual connections from
% TOC to chapters, this can be removed if needed
% EDIT: Here is defined the pdf -metadata.
\usepackage[breaklinks,pdftex,
  pdfauthor={Kevin Rogovin},
  pdftitle={Architecture Concept},
  pdfsubject={Tri-Buffer Rendering}]{hyperref}
\usepackage{html}   %  *always* load this for LaTeX2HTML


% Next we create the Nomovok -header, here we need some
% fancywork

% Erase old header and footer
\fancyhead{}
\fancyfoot{}
% Creation of the Nomovok header
\fancyhead[C]{
  % Remove cell padding from this tabular
  % 6pt (2.12mm) is the regular cell padding
  \addtolength{\tabcolsep}{-6pt}
  {\small
  \begin{tabular}{@{}l@{}@{}l@{}l@{}r@{}}
    % Row 1, with Logo
    \includegraphics[width=4.1cm]{nomovok_logo_large}&
    &  & \thepage (\pageref{LastPage}) \\    
    % Row 2
    % EDIT as needed
    N/MOBU & Architecture Concept & DRAFT &\\
    % Row 3
    % EDIT as needed
    \parbox[T]{3.8cm}{CONFIDENTIAL} & Tri-Buffer Rendering & \todayiso &\\
    % A phantom row to match that in the .odt -version, used here to
    % set the column widths to match those in the .odt
    \multicolumn{1}{p{4.47cm}}{} & 
    \multicolumn{1}{p{6.5cm}}{} & 
    \multicolumn{1}{p{3.84cm}}{} & 
    \multicolumn{1}{p{3.10cm}}{}\\
  \end{tabular}
  }
}

\fancyfoot{
	\centering
	\small
The contents of this document are Copyright \copyright~Nomovok Ltd. 2011.
}

% Some more setup for the document
\addtolength{\headsep}{-0.5cm}
\setlength{\headheight}{75pt}

% Set header to not have a visible line
\renewcommand{\headrulewidth}{0.0pt}

% Set baselineskip to be one and a half line
\renewcommand{\baselinestretch}{1.5}

% Setting up hyperref colorings
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black}

%Create own custom environment for indenting plain text:
\def\indenter#1{\list{}{\leftmargin#1}\item[]}
\let\endindenter=\endlist


% This fixes pdflatex page size, without breaking normal latex usage
% possibly not needed, but it never hurts to be sure.
\usepackage{ifpdf}
\ifpdf
\setlength{\pdfpagewidth}{210mm}
\setlength{\pdfpageheight}{297mm}
\else
\fi

\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black}

\begin{document}
%\begin{titlepage}
\begin{center}

% Let's align the Title vertically
\vspace*{105.5pt}
% EDIT here the heading and type of document
{\LARGE \bf Tri-Buffer Rendering}\\
{\LARGE \bf Architecture Concept}\\
\vspace{71pt}

% Creation of the title-page table
% EDIT here the needed information
{
\setstretch{1.3}
\begin{tabular}{lll}
  &Document Code: & PAGE-131600 \\ 
  &Version: & 0.2 \\ 
  &Date: & \todayiso \\ 
  &Author: & Kevin Rogovin \\ 
  &Owner: & Juha Hytönen \\ 
  &Approver: & - \\
  % Again fix the widths to those in the .odt
  \multicolumn{1}{p{3.83cm}}{} &
  \multicolumn{1}{p{4.17cm}}{} & 
  \multicolumn{1}{p{8.00cm}}{}\\
\end{tabular}
}

\small
This document and its contents are considered as confidential and are to be distributed only to Nomovok, Aisin AW and limited Renesas personnel. 
Any unauthorized review, use, disclosure or distribution is prohibited. 

\end{center}

\newpage

\noindent\textbf{Change History:}
\label{sec:changelog}
\begin{table}[h!tbp]
  \begin{tabular}{rllll}
    \multicolumn{1}{c}{\textbf{\textit{Version:}}}& 
    \multicolumn{1}{c}{\textbf{\textit{Date:}}} & 
    \multicolumn{1}{c}{\textbf{\textit{Author:}}} &
    \multicolumn{1}{c}{\textbf{\textit{Status:}}} &
    \multicolumn{1}{c}{\textbf{\textit{Changes made:}}}\\
    % EDIT: Insert own lines here as version changes
    0.1 & 2011-08-25 & Kevin Rogovin & DRAFT & Initial version \\
    0.1 & 2011-10-04 & Juha Hytönen & DRAFT & Documentization \\
    %This is just for proper widths to the tabular
    \multicolumn{1}{p{1.8cm}}{}&
    \multicolumn{1}{p{2.18cm}}{}&
    \multicolumn{1}{p{3.42cm}}{}&
    \multicolumn{1}{p{2.31cm}}{}&
    \multicolumn{1}{p{6.2cm}}{}\\
  \end{tabular}
\end{table}

\newpage

% Use the same name for contents as .odt
\renewcommand{\contentsname}{Table of Contents}
% Create TOC
{
\singlespacing
\tableofcontents
}

\setlength{\parindent}{0pt}

\newpage
% EDIT: Okay, and now starts the actual body of the document.

\section{Problems of Linux Video Subsystems on Embedded Devices}
\begin{indenter}{2cm}

The following is set of thoughts, frustrations and hopes for dealing with
video subsystem of Linux based OS's for embedded devices.

Let us first define the problem(s) that we need to solve for such devices:

\begin{enumerate}
\item We need a compositor which presents the contents of the windows of applications
to the screen. The compositor can/will perform blending and possibly geometry
transformations when presenting the window data.
\item We need to allow for applications to run "full screen" and bypass the
compositor, or at the very least allow for the compositor to know that a
particular window is "full screen" and to only present it's contents.
\end{enumerate}

\end{indenter}
\subsection{The Compositor}
\begin{indenter}{2cm}
  
Let us first discuss the compositor, which is the more painful of the two problems.
Essentially the idea of what is to happen is the following:

\begin{enumerate}
\item Application renders to offscreen buffer B.
\item Compositor draws offscreen buffer B as a GL texture.
\end{enumerate}

From the above we immediately see that the buffer B should
then be shared memory between the Application process and
the Compositor process and also immediately consumable by
OpenGL as a texture. The story deepens though: \textbf{we do not wish
for the application to draw to the buffer B while the compositor
is drawing B to the screen}. Hence we need to double buffer and lock
at the very least. However, there is a better approach with triple
buffering that will make the locking operation between the
Compositor and Application minimal.

The process is as follows: rather than allocating one buffer,
we allocate three buffers \textit{B[0]}, \textit{B[1]}, \textit{B[2]} and additionally a small amount of state:

\begin{verbatim}
struct
{
   Buffers B[3];
   int last_buffer_written_to_by_application;
   int buffer_application_is_writing_to;
   int buffer_that_compositor_is_presenting;
}
\end{verbatim}

A lock will only "mutex\_lock" the three integers:
\begin{itemize}
\item \textit{last\_buffer\_written\_to\_by\_application},
\item \textit{buffer\_application\_is\_writing\_to} and
\item \textit{buffer\_that\_compositor\_is\_presenting}.
\end{itemize}

These values will guarantee that one does \textbf{NOT} need to lock
the buffers \textit{B[3]} and that the Application and Compositor will
only need to wait for each other while the values those three
integers are changed by the other, i.e. only 12 bytes, \textbf{NOT} entire buffers and blits.

The Compositor and Application work together as follows:

Application at eglSwapBuffers:
\begin{verbatim}
lock()

/* Set state to indicate which is the latest and greatest from the Application. */
last_buffer_written_to_by_application=buffer_application_is_writing_to;

/*
By logic, after the above assignment
we are guaranteed that last_buffer_written_to_by_application
is NOT the same as buffer_that_compositor_is_presenting.
*/
assert(buffer_that_compositor_is_presenting!=buffer_that_compositor_is_presenting);

/* Choose the next buffer to render to. */
buffer_application_is_writing_to=I 

/* 
I is 0,1 or 2 AND the values of last_buffer_written_to_by_application,
buffer_that_compositor_is_presenting and buffer_application_is_writing_to 
are distinct.
*/

unlock()

/* 
   Set Application internal state to draw to buffer 
   B[buffer_application_is_writing_to]. 
*/

\end{verbatim}              
              
Compositor:
\begin{verbatim}
lock();

buffer_that_compositor_is_presenting=last_buffer_written_to_by_application;

/*
The logic of this setup guarantees that buffer_that_compositor_is_presenting
is never the same as buffer_application_is_writing_to.*/

assert(buffer_application_is_writing_to!=buffer_that_compositor_is_presenting);

unlock();

/* Set Compositor internal state to draw buffer B[buffer_that_compositor_is_presenting]. */
\end{verbatim}

\textbf{The above allows for the Compositor and Application to run almost completely asynchronously
as the operations within a lock only reads/writes 12 bytes.}

This is all we need for the synchronization logic between the compositor
and a client Application. We also need that whatever way the compositor is drawing
that it can accept the memory of the buffers as source from which to blit. More
concretely, as we intend to (and do) use a flavor of OpenGL to do the actions
of the Compositor, we need:

\begin{itemize}
\item Cross process image data that can be written to by an Application and
used as a texture directly by the Compositor's GL context.
\end{itemize}

That is all we need for fixed sized window display. For changing window
sizes, we need to resize the buffers (or really free and allocate) the buffers.
If we read between the lines, we are essentially requiring a global memory manager
for the memory used by the graphics hardware. For embedded hardware this is usually
the same as main RAM.

So at the end of the day, all we need is cross-process image sharing
and we have the compositor draw with GL directly to a double-buffered
framebuffer. For the compositor, eglSwapBuffers() translates to a pointer
swap for double buffering (and whatever else the OpenGL implementation
needs to perform to finish rendering to the surface).

\end{indenter}
\subsection{Full Screen Applications}
\begin{indenter}{2cm}

The fullscreen case is much simpler: we put the Compositor to sleep and
let the application take over the device's framebuffer.

\end{indenter}
\subsubsection{Partial Updates}
\begin{indenter}{2cm}

One final note, the above does NOT allow for partial updates. As a
side note, Qt does not support partial updates together with EGL.
There is a way to allow for partial updates for the Application:
we memcopy the contents of B[last\_buffer\_written\_to\_by\_application] to
B[buffer\_application\_is\_writing\_to] after the unlock() in the
Application process. Again this will not take place within the lock,
but will defeat the usual purpose for partial updates: touch fewer bytes.

Indeed, partial updates is now a red-herring in terms of enhancing
performance for many embedded devices. The easiest example to cite
the architecture of the PowerVR SGX. In the SGX, the rendering
proceeds as follows:

\begin{quote}
GL application calls glDrawStuff(). For SGX this does NOT
trigger a change to the surface that is being drawn to. Rather,
the SGX breaks the screen into regions (called tiles). When
glDrawStuff() is called, the SGX computes which primitives of
that call affect which tiles and append to those tiles the
primitives that affect them to their "polygon lists". When
eglSwapBuffers() is called, the SGX for each tile, renders
the contents of the polygon lists to \textbf{SRAM} on the GPU and
then copies the results out to the surface. The advantage
here is that rendering is to SRAM, which is latency free.
In order to do partial updates, it would first need to copy
the contents of the surface to SRAM. (As a side note, ARM Mali
also operates this way, the big difference between SGX and Mali
is that SGX performs the rendering in essentially 2 passes
which when used correctly, reduces overdraw remarkably, this
is the differed renderer of SGX).
\end{quote}

\end{indenter}
\section{Tri-Buffer Alternatives}
\begin{indenter}{2cm}

However, where are we now? We have two choices:
\begin{itemize}
\item X11+XComposite+EGL or
\item Wayland+EGL+SomethingThatTalksToSomethingToTalkToHardware.
\end{itemize}

\end{indenter}
\subsection{X11+XComposite+EGL}
\begin{indenter}{2cm}

A good, high performing X11 driver is a \textbf{HUGE} implementation burden.
To give perspective on the magnitude of the burden, during an embedded device development
project the hardware provider had 60+ developers writing an X11 driver. That was about the same number
of people Nomovok used to deliver all other software components.

To put it gently, \textbf{X11 solves a different host of issues, which in all
honesty we are not interested in solving for an embedded device}. Indeed
the main point of the ideas of XServer, is that an application runs on
a different devices than it is to be displayed on and this operation is
transparent to the application. We have no use to solve this problem,
worse we wish to use the GPU to draw, which means using OpenGL ES2, for
which there is no network protocol anyways.

Secondly, X11 "thinks" a touch differently than what we are aiming to do.
The XComposite on top of X11 on the surface does sort of what we need
(namely we get a pixmap for the window of each application) but the
implementation burden because of the framework which X11
provides is significant without providing any advantage. Additionally,
\textbf{the vast majority of the X11 driver work will be on functionality
that we do not use}.

Thirdly, just \textbf{using X11 as a developer is unpleasant}. Indeed, both
EGL and X11 have API points to choose the bit-depth of the pixels,
and when one wishes to make a surface to which to have GL draw, those
bit-depths must match. Additionally if they don't match with something
else, there is a potential of an overhead of conversion between bit
depths is executed by the X11 driver and if not done properly by the X11
driver implementation, potentially by the CPU.

Fourthly, \textbf{EGL also requires more than we need}. Indeed it has a somewhat
messy interface for just specifying a surface to draw to.

\end{indenter}
\subsection{Wayland+EGL+SomethingThatTalksToSomethingToTalkToHardware}
\begin{indenter}{2cm}

Wayland is JUST a protocol, so strictly speaking the outlined
approach is doable by Wayland. The
SomethingThatTalksToSomethingToTalkToHardware can be that unified memory
manager. So far so good, except for EGL. Again as stated above,
EGL requires much more that we need.

Let now address what goes wrong often.

The core EGL specification does NOT provide a means to share
image data across process boundaries. However there are the two
extensions that appear to be expressly for the purpose of compositing: 

\begin{indenter}{4cm}
EGL\_KHR\_image\_pixmap\footnote{http://www.khronos.org/registry/egl/extensions/KHR/EGL\_KHR\_image\_pixmap.txt} \\
GL\_OES\_EGL\_image\footnote{http://www.khronos.org/registry/gles/extensions/OES/OES\_EGL\_image.txt}. \\
\end{indenter}

When using glX instead of EGL, we need to have GLX\_EXT\_texture\_from\_pixmap\footnote{http://www.opengl.org/registry/specs/EXT/texture\_from\_pixmap.txt} and
we also need XComposite extension in the X11 implementation.

Without the necessary extensions, we hack around this by essentially
copying the image data to a QImage and using that QImage to generate
a GL texture. This forces \textbf{two} potential format conversions and
\textbf{two} extra blits, to get NOTHING done aside from work around an API
and framework which is insufficient for our goals.


Lastly, and this is worth pointing out. Some SoC's provide a quality
X11+EGL implementation already. However, the work that was needed
for it cannot be understated. If an SoC does not already have a
\textbf{GOOD} X11+EGL+XComposite implementation ready, with the necessary
extensions, we are unable to provide a system that has any hope in
competing with other devices on the market. My opinion is that unless
the X11 implementation is already *perfect* then we are in for a
rough ride.

\end{indenter}
\subsection{Non-Linux Systems}
\begin{indenter}{2cm}

Mac-OSX (which is Unix based) does not use X11 as it's video
sub-system. Indeed, Apple realized this over \textbf{TEN} years ago that X11
was not the correct tool for the job (as a side note, they have
a thin X11 server that uses the Mac-OSX rendering subsystem). Additionally
iOS (of iPhone, iPad) does NOT use EGL either, but an Apple specific API
that stresses one is rendering to an offscreen buffer\footnote{http://developer.apple.com/library/ios/\#documentation/QuartzCore/Reference/CAEAGLLayer\_Class/CAEGLLayer/CAEGLLayer.html}.

\end{indenter}
\section{The Proposal}
\begin{indenter}{2cm}

The best path forward is as follows:

\begin{enumerate}
\item Observe that Wayland is \textbf{only} a protocol that provides for buffer
handling and event handling. We can use the Wayland protocol to implement
the triple buffering scheme.
\item We need a fixed API for creating these shareable buffers (three per window).
My personal opinion is that fixating on EGL is a \textbf{bad} idea. \textbf{There are ways
to make EGL work with this approach, but the implementation burden is significant
as well.} Moreover, EGL provides bits that are not necessarily what we need
or want in this case anyways. I strongly urge that we specify a relatively
simple API for shareable buffers across process boundaries that can be written
to by a GL implementation and used as a texture source. In spirit, I am asking
for cross-process GL texture support. As a side note, Apple's API has an
application create a GL RenderBuffer (this is part of the framebuffer object
API of GL) and to use that renderbuffer with a CAEGLLayer. I advise something
a little higher level that "hides" the triple buffering from the Application
so that an application has a single call to "say buffer is ready for use".
\item We need to create the "backend" bits for Steelgraph to use
this way of creating windows.
\item Lastly, we need to explore what a developer (for example games) should do
when they do not wish to use Qt. I suggest the following:
    \begin{enumerate}
    \item Create a (very) simple API for window creation and event fetching.
    \item Patch SDL to use that API.
    \item Tell developers to use SDL or the simple API directly.
    \end{enumerate}
\end{enumerate}

\end{indenter}



\end{document}
