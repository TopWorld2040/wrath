% Latex -template for writing Nomovok Documents
% Places outside of the regular text (headers etc.)
% that need to be edited are marked with comments
% beginning with 'EDIT'

\documentclass[a4paper,11pt]{article}

% First we need to include quite a bit of packages

% Use UTF-8 
\usepackage{ucs}
\usepackage[utf8x]{inputenc}

% Set font to Helvetica
% This is different from the .odt where
% Arial is used, but Arial and Helvetica
% are almost identical, for further info:
% http://www.ms-studio.com/articles.html
\usepackage[T1]{fontenc}
\usepackage{helvet}
\renewcommand*\familydefault{\sfdefault}

% To allow proper header/footer
\usepackage{fancyhdr}

% Set margins and page size
\usepackage[left=2cm,right=1cm,bottom=3.5cm,top = 2.3cm,a4paper]{geometry}

% Use the fancy header
\pagestyle{fancy}

% To obtain last page number
\usepackage{lastpage}

% For control over the output of date/time
\usepackage{datetime}

% Creation of a custom time output format
\renewcommand{\dateseparator}{.}
\newcommand{\todayiso}{\twodigit\day\dateseparator\twodigit\month\dateseparator\the\year}

% Allow insertion of figures into the document
\usepackage{graphicx}

% Allow setting of spacing for ex. table of contents
\usepackage{setspace}

% Recognize urls and pdf -links,
% breaklinks breaks the usual connections from
% TOC to chapters, this can be removed if needed
% EDIT: Here is defined the pdf -metadata.
\usepackage[breaklinks,pdftex,
  pdfauthor={Kevin Rogovin},
  pdftitle={Architecture Concept},
  pdfsubject={Image Sharing between Processes}]{hyperref}
\usepackage{html}   %  *always* load this for LaTeX2HTML


% Next we create the Nomovok -header, here we need some
% fancywork

% Erase old header and footer
\fancyhead{}
\fancyfoot{}
% Creation of the Nomovok header
\fancyhead[C]{
  % Remove cell padding from this tabular
  % 6pt (2.12mm) is the regular cell padding
  \addtolength{\tabcolsep}{-6pt}
  {\small
  \begin{tabular}{@{}l@{}@{}l@{}l@{}r@{}}
    % Row 1, with Logo
    \includegraphics[width=4.1cm]{nomovok_logo_large}&
    &  & \thepage (\pageref{LastPage}) \\    
    % Row 2
    % EDIT as needed
    N/MOBU & Architecture Concept & DRAFT &\\
    % Row 3
    % EDIT as needed
    \parbox[T]{3.8cm}{CONFIDENTIAL} & Image Sharing between Processes & \todayiso &\\
    % A phantom row to match that in the .odt -version, used here to
    % set the column widths to match those in the .odt
    \multicolumn{1}{p{4.47cm}}{} & 
    \multicolumn{1}{p{6.5cm}}{} & 
    \multicolumn{1}{p{3.84cm}}{} & 
    \multicolumn{1}{p{3.10cm}}{}\\
  \end{tabular}
  }
}

\fancyfoot{
	\centering
	\small
The contents of this document are Copyright \copyright~Nomovok Ltd. 2011.
}

% Some more setup for the document
\addtolength{\headsep}{-0.5cm}
\setlength{\headheight}{75pt}

% Set header to not have a visible line
\renewcommand{\headrulewidth}{0.0pt}

% Set baselineskip to be one and a half line
\renewcommand{\baselinestretch}{1.5}

% Setting up hyperref colorings
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black}

%Create own custom environment for indenting plain text:
\def\indenter#1{\list{}{\leftmargin#1}\item[]}
\let\endindenter=\endlist


% This fixes pdflatex page size, without breaking normal latex usage
% possibly not needed, but it never hurts to be sure.
\usepackage{ifpdf}
\ifpdf
\setlength{\pdfpagewidth}{210mm}
\setlength{\pdfpageheight}{297mm}
\else
\fi

\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black}

\begin{document}
%\begin{titlepage}
\begin{center}

% Let's align the Title vertically
\vspace*{105.5pt}
% EDIT here the heading and type of document
{\LARGE \bf Image Sharing between Processes}\\
{\LARGE \bf Architecture Concept}\\
\vspace{71pt}

% Creation of the title-page table
% EDIT here the needed information
{
\setstretch{1.3}
\begin{tabular}{lll}
  &Document Code: & PAGE-131600 \\ 
  &Version: & 0.2 \\ 
  &Date: & \todayiso \\ 
  &Author: & Kevin Rogovin \\ 
  &Owner: & Juha Hytönen \\ 
  &Approver: & - \\
  % Again fix the widths to those in the .odt
  \multicolumn{1}{p{3.83cm}}{} &
  \multicolumn{1}{p{4.17cm}}{} & 
  \multicolumn{1}{p{8.00cm}}{}\\
\end{tabular}
}

\small
This document and its contents are considered as confidential and are to be distributed only to Nomovok, Aisin AW and limited Renesas personnel. 
Any unauthorized review, use, disclosure or distribution is prohibited. 

\end{center}

\newpage

\noindent\textbf{Change History:}
\label{sec:changelog}
\begin{table}[h!tbp]
  \begin{tabular}{rllll}
    \multicolumn{1}{c}{\textbf{\textit{Version:}}}& 
    \multicolumn{1}{c}{\textbf{\textit{Date:}}} & 
    \multicolumn{1}{c}{\textbf{\textit{Author:}}} &
    \multicolumn{1}{c}{\textbf{\textit{Status:}}} &
    \multicolumn{1}{c}{\textbf{\textit{Changes made:}}}\\
    % EDIT: Insert own lines here as version changes
    0.1 & 2011-09-30 & Kevin Rogovin & DRAFT & Initial version \\
    0.1 & 2011-10-04 & Juha Hytönen & DRAFT & Documentization \\
    %This is just for proper widths to the tabular
    \multicolumn{1}{p{1.8cm}}{}&
    \multicolumn{1}{p{2.18cm}}{}&
    \multicolumn{1}{p{3.42cm}}{}&
    \multicolumn{1}{p{2.31cm}}{}&
    \multicolumn{1}{p{6.2cm}}{}\\
  \end{tabular}
\end{table}

\newpage

% Use the same name for contents as .odt
\renewcommand{\contentsname}{Table of Contents}
% Create TOC
{
\singlespacing
\tableofcontents
}

\setlength{\parindent}{0pt}

\newpage
% EDIT: Okay, and now starts the actual body of the document.

\section{Problem Definition}
\begin{indenter}{2cm}

The purpose of this document is to enumerate the end goals of an API for allocating and sharing data across process
boundaries for the purposes of graphics. In essence we need to have an API that allows for:
\begin{enumerate}
\item Allocation of image data and modification of that image data in a process A
\item Usability of that image data in other processes as GL textures. However, modification of the image data (pixel values and backing store) can only be done in the process that created the image data, i.e. only process A has write access, all others have read access.
\item Such image buffers are also valid location to which to place decoded video frames.
\end{enumerate}

\end{indenter}
\subsection{Compositing}
\begin{indenter}{2cm}

The basic idea here is that an application draws to an offscreen buffer and a compositor will present that buffer. The coordination between the compositor and the application will be such that the compositor will \textbf{NOT} use an image source while an application is writing to it. The easiest way to achieve this is with a triple buffer scheme: An application A, allocates 3 image buffers to which it will write, call those buffers \textit{A.B[0]}, \textit{A.B[1]} and \textit{A.B[2]}. The application and compositor are coordinated by using three integers whose values are 0, 1 or 2 and a mutex
\begin{enumerate}
\item int A.presentID, 
\item int A.currentWriteID, 
\item int A.lastWriteID
\item mutex A.M
\end{enumerate}

The application and compositor cooperate as follows.

In the application process:
\begin{verbatim}
// At the end of each rendered frame:
glFinish();
LockMutex(A.M);
A.lastWriteID=A.currentWriteID;
A.currentWriteID= value in {0,1,2} which is different from A.{presentID,lastWriteID}
UnlockMutex(A.M);

// Set state to indicate to draw to B[A.currentWriteID], i.e. the new 
// “back buffer” is  B[A.currentWriteID]. Additionally, the “front 
// buffer” is now B[A. lastWriteID].
\end{verbatim}

In the compositor process:
\begin{verbatim}
// Drawing contents of application A:
LockMutex(A.M);
A.presentID=A.lastWriteID;
UnlockMutex(A.M);

glBindTexture(GL_SOME_TEXTURE_TARGET, A.B[A.presentID] );
DrawQuad();
\end{verbatim}
	
This method allows for applications and the compositor to run almost entirely asynchronously with no extra copying and with a guarantee that the compositor will not use the buffer to which the application is writing. 

\end{indenter}
\subsection{Sharing of Resources}
\begin{indenter}{2cm}

Resources include fonts, theme image data, etc. In these use cases, a single process, a daemon, updates image data by directly specifying pixels (for example via \textit{glTexSubImage2D} calls). Below is an example in pseudo-code of a font server and an application.

In the application process:
\begin{verbatim}
texID=textureID for cross process image of font data
texes=cross_process_call::font_server_request_texture_coordinates_for_glyph(G);
// Function does not return until after the image data for glyph G
// has been generated.

.
.
glBindTexture(GL_SOME_TEXTURE_TARGET_FOR_USING_TEXTURE, textureID);
DrawQuads(); // For example.
\end{verbatim}

In the font server process:
\begin{verbatim}
Mutex fontMutex;
std::map<GlyphCode, GlyphData*> glyph_data;

texture_coordinates_type font_server_request_texture_coordinates_for_glyph(G)
{
   GlyphData *buffer_data;

   LockMutex(fontMutex);
   std::map<GlyphCode, GlyphData*>::iterator iter;
            
   iter=glyph_data.find(G);
   if(iter!=glyph_data.end())
   {
     buffer_data=iter->second; 
   }
   else
   {  
     buffer_data=new GlyphData(G);
     glyph_data[G]=buffer_data;
     
     // Update contents of buffer data for new font data:
     glTexSubImage2D(GL_SOME_TEXTURE_TARGET_FOR_UPDATING_TEXTURE, ...., 
                     buffer_data->m_pixels);
   }
   UnlockMutex(fontMutex);

   return buffer_data->texture_coordinates();
}
\end{verbatim}

In this example any texture data that the application uses is guaranteed to not change (but other portions of the texture are free to change). Additionally, the size of the texture is to be static as well, and hence it's location in memory may also be static (to ease possible implementation burden). A key point for the above use case is that the underlying image need not be RGBA8 or RGB8, the pixels can be a floating point values, half floating point values, and have 1 or 2 channels. Additionally although not explicitly mentioned above, the underlying image data may have mipmap levels defined. Moreover, it is NOT necessary for the font server to have a real GL context, it needs only to be able to allocate the image data and write to that data. As such, using glTexSubImage2D is not necessary, just an API call that can be used to modify that data. 

\end{indenter}
\subsection{Video Decode}
\begin{indenter}{2cm}

The OpenMAX AL does specify that one can decode to an EGLImage. That API allows  (in an ideal implementation) one to avoid unnecessary format conversions and blits.  Indeed, without that API, in order to present decoded video with the GL API, one must get the pixel values of the decoded image, possibly convert those values to a format the OpenGL ES2 specification allows (such as RGB565, RGB8, etc) and call \textit{glTexSubImage2D}. The call to \textit{glTexSubImage2D} is another blit which might also incur another format conversion as dictated by the GL implementation. Thus without decode to EGLImage, we find that 2 additional blits and possibly 2 additional format conversions are required. 

In an ideal situation for multimedia decode, the decoder is a separate process than the application presenting the data. The point being that if the decoder hangs or crashes (say as a result of bad input data), the presenting application can perform recovery. In this regard, again the ability to share image data across process boundaries is needed. Using the same triple buffering logic as found in compositing, we can play audio and decode video from a separate process than the presenting process. The presenting process can also perform special effects on the data (such as texture mapping the data to an object and/or perform post-processing in the fragment shader). With regards to post-processing the texture data in a fragment shader, the fragment shader can also be used to perform color space conversion (for example YUV to RGB) and also provide high quality magnification (for example bicubic magnification) without the need for additional dedicated hardware.

\end{indenter}
\section{Proposed Solution - The APIs}
\begin{indenter}{2cm}

The following is a proposal and can be changed to alleviate implementation burden. Our first API proposal is not built on top of EGL. Indeed, the EGL specification provides significantly more functionality than we require (for example we do not wish to have surfaces associated to windows). We only require the ability to create a context which does NOT have a default framebuffer. Below is a proposal.

\begin{verbatim}
/*
 Returns a GL context which does NOT have a default
 framebuffer. 

 \param attrib_list is terminated with NGL_NONE and is used to specify  
        (in an extendable way) the nature of the GL context. The parameter 
        NGL_CONTEXT_TYPE must be provided and depending on hardware support 
        maybe one of NGL_GLES1, NGL_GLES2 or NGL_GL specifies what kind of 
        rendering context to create (OpenGL ES1, OpenGL ES2 or OpenGL 
        respectively). Other properties can be added later (for example in 
        creating  a GL context specifying GL version, compatibility or 
        core profiles, etc as in wgl/glxCreateContextAttribsARB).

 \param share_ctx if not NGL_NO_CONTEXT, then the created context 
        and share_ctx will belong to the same share group. Contexts 
        within the same share group share objects (for example for 
        NGL_GLES2, textures, buffer objects, etc).

 \return NGL_NO_CONTEXT on failure to create a context, 
         otherwise creates the context.
*/
NGLcontext
nglCreateContext(NGLDisplay dpy, NGLint *attrib_list, NGLcontext share_ctx);

/*
 Make the given context current. Passing NGL_NO_CONTEXT indicates to have it so 
 that no context is current.
 
 \return NGL_FALSE on failure and NGL_TRUE on success
*/
NGLBoolean
nglMakeCurrent(NGLDisplay dpy, NGLContext ctx);

/*
 Destroy a context, the context may not be current.
 
 \return NGL_FALSE on failure and NGL_TRUE on success.
*/
NGLBoolean
nglDestroyContext(NGLDisplay dpy, NGLContext ctx);

/*
 Import the language of EGLImageKHR and EGL_KHR_image_base
 to allow for creating and NGLImage (the analogue in this API
 of EGLImage) from textures and other sources and to have
 a GL texture from an NGLImage.
*/
NGLImage
nglCreateImage(NLDisplay dpy, NGLContext ctx, 
               NGLenum target, NGLClientBuffer buffer, 
               const NGLint *attrib_list)

NGLBoolean
nglDestroyImage(NGLDisplay dpy, NGLImageKHR image);

/*
 \return an NGLint that can be used by another process to 
         get an NGLImage from it. 

 \param im NGLImage image from which to generate a handle.  Conditions for use:
         The backing store of the NGLImage is created in the process of the 
         caller and the memory location and layout of that backing store is 
         static (i.e. the contents of the image can change but not it's layout
         for example rendering to the texture or using glTexSubImage2D is legal,
         but calling glTexImage2D is illegal). An implementation can optionally
         remove this requirement and allow for the backing store's format and
         size to change during the lifetime of the NGLImage.
*/
NGLInt
nglCreateHandleFromImage(NGLImage im);


/*
 \return an NGLImage whose backing store is the backing store of the NGLImage
            that was used in calling nglCreateHandleFromImage() from another 
            process.
 
 The contents of the backing store NGLImage can only be changed by the
 process that created the backing store [the requirement can be lifted 
 in a later extension].

 Also note that we will also need to provide an analogue to GL_OES_EGL_image's 
 glEGLImageTargetTexture2DOES which can take as argument an NGLImage for example:

 glNGLImageTargetTexture2DNGL(enum target, NGLImage img)

 where target must be GL_TEXTURE_2D. When called, it specifies that the backing 
 store of the currently bound texture will use as it's backing store the backing 
 store of the specified NGLImage im. Later extensions may allow for other values 
 of target besides GL_TEXTURE_2D. When a texture's backing store comes from an 
 NGLImage, it is then illegal for that texture data to be modified. Future 
 extensions may lift this restriction. However, setting various texture filtering
 parameters and wrap modes is legal. Only those calls that affect the pixel data 
 (not how the data is processed by GL) are not allowed.
*/
NGLImage
nglImageFromHandle(NGLint);

\end{verbatim}

An application may initialize itself for rendering with the OpenGL ES2 API (for example) as follows:

\begin{verbatim}

NGLDisplay application_display;
NGLContext application_ctx;
GLuint application_fbos[3];
GLuint application_color_buffers[3];
GLuint application_depth_stencil_buffers[2];

NGLImage application_color_buffers_as_images[3];
NGLint application_color_buffers_as_handles[3];

void
init(int w, int h, NGLDisplay dsp)
{
   NGLint attrs[]=
    {
       NGL_CONTEXT_TYPE, NGL_GLES2,
       NGL_NONE
    };

   application_display=dsp;
   application_ctx=nglCreateContext(application_display, attrs, NGL_NO_CONTEXT);
   assert(application_ctx!=NGL_NO_CONTEXT);

   nglMakeCurrent(application_display, application_ctx);

   glGenFramebuffers(3, application_fbos);
   glGenTextures(3, application_color_buffers);

   if(!packed_depth_stencil_supported)
   {
      
      glGenRenderBuffers(2, application_depth_stencil_buffers);
   
      // Create depth buffer.
      glBindRenderBuffer(GL_RENDERBUFFER, application_depth_stencil_buffers[0]);
      
      // Or use if available, GL_DEPTH_COMPONENT24_OES or 32.
      glRenderBufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, w, h); 
     
      // Create stencil buffer.
      glBindRenderBuffer(GL_RENDERBUFFER, application_depth_stencil_buffers[1]);
      glRenderBufferStorage(GL_RENDERBUFFER, GL_STENCIL_INDEX8, w, h);   
   }
   else
   {      
      glGenRenderBuffers(1, application_depth_stencil_buffers);
      application_depth_stencil_buffers[1]=application_depth_stencil_buffers[0];

      glBindRenderBuffer(GL_RENDERBUFFER, application_depth_stencil_buffers[0]);
      glRenderBufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8_OES, w, h);  
   }

   glViewport(0, 0, w, h);   
   for(int i=0;i<3;++i)
   {
       glBindFramebuffer(GL_FRAMEBUFFER, application_fbos[i]);

       // Create color buffers as RGBA8:
       glBindTexture(GL_TEXTURE2D, application_color_buffers[i]);
       glTexImage2D(GL_TEXTURE2D, 0, GL_RGBA, 
                    w, h, 0, GL_RGBA, GL_UNSIGNED_BYTES, NULL);

       glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, 
                              GL_TEXTURE_2D, application_color_buffers[i], 0);

       glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, 
                                 GL_RENDERBUFFER, 
                                 application_depth_stencil_buffers[0]);
 
       glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, 
                                 GL_RENDERBUFFER, 
                                 application_depth_stencil_buffers[0]);
       
       application_color_buffers_as_images[i]
           =nglCreateImage(dpy, application_ctx, 
                           GL_TEXTURE2D, application_color_buffers[i]);

       application_color_buffers_as_handles[i]
           =create_handle_from_image(application_color_buffers_as_images[i]);
   }

 // Communicate to compositor/window manager the handles for the color buffers.
 message_to_compositor_buffers_for_application(application_color_buffers_as_handles);
   
}
\end{verbatim}

The above example API and usage are proposals only and are to be modified and tweaked for a hardware platform provider to minimize overhead and implementation burden. Additionally, for the case for hardware video decode, we have not provided (yet) a starting point. Ideally, an \textit{NGLImage} can be interchanged with a \textit{EGLImage} in the Open MAX AL specification to allow for decode and presentation with minimal copying of data.

In the situation where a hardware provider insists on using and extending EGL, we propose to add the following EGL extension:
\begin{indenter}{1cm}
\begin{verbatim}
EGL_Surfaceless_ctx

The purpose of this extension is to allow an application to 
have a rendering context which does not have a default framebuffer.  

Additions to 3.7.3  Binding Contexts and Drawables 
of the EGL 1.4 Specification:


Modify “If either draw or read are not valid EGL surfaces, an 
EGL_BAD_SURFACE error is generated. ” to “If either draw or read 
are not valid EGL surfaces, an EGL_BAD_SURFACE error is generated. 
However, no error is generated if both draw and read are both EGL_NO_SURFACE, 
then the context does not have a default framebuffer (and hence the API of 
the associated context needs to support the ability create render targets 
which to draw and or from which to read, for example GL's framebuffer API)”.

\end{verbatim}
\end{indenter}

together with an extension to allow to share EGLImage's across process boundaries:

\begin{verbatim}

/*
 \return an EGLint that can be used by another process to get an EGLImage from it.

 \param im EGLImage image from which to generate a handle.

  Conditions for use:
  1) The backing store of the EGLImage is created in the process of the caller and
     the memory location and layout of that backing store is static (i.e. the 
     contents of the image can change but not it's layout for example rendering to 
     the texture or using glTexSubImage2D is legal, but calling glTexImage2D is 
     illegal).
*/
EGLInt
eglCreateHandleFromImage(EGLImage im);

/*
 \return an EGLImage whose backing store is the backing store of the EGLImage
         that was used in calling eglCreateHandleFromImage() from another process.
 
 The contents of the backing store EGLImage can only be changed by the
 process that created the backing store [the requirement can be lifted in a later
 extension].
*/
EGLImage
eglImageFromHandle(EGLint);
\end{verbatim}

Another approach is that an the EGL implementation is changed so that:
\begin{enumerate}
\item Allow for allocation of triple buffered buffered surfaces (by extending EGL by allowing for a new value for \textit{EGL\_RENDER\_BUFFER}, \textit{EGL\_TRIPLE\_BUFFER\_NMK}).
\item \textit{eglSwapBuffers()} performs the update of \textit{A.lastWriteID} and \textit{A.currentWriteID} at \textit{eglSwapBuffers()}. Additionally if \textit{EGL\_SWAP\_BEHAVIOR} is \textit{EGL\_BUFFER\_PRESERVED} then at \textit{eglSwapBuffers()} after \textit{A.lastWriteID} and \textit{A.currentWriteID} are updated, the contents of \textit{A.B[A.lastWriteID]} are copies to \textit{A.B[A.currentWriteID]}.
\item Creation of single and double buffered windowed EGLSurface with \textit{eglCreateWindowSurface()} is not possible, i.e. EGL will always create a triple buffered surface for window surfaces. 
\item If a windowed \textit{EGLSurface} is a triple buffered window surface (i.e. \textit{EGL\_RENDER\_BUFFER} is \textit{EGL\_TRIPLE\_BUFFER\_NMK}) is used in \textit{eglMakeCurrent}, then both the read and draw arguments must be that same \textit{EGLSurface}.
\item Extend EGL so that a compositor can set \textit{A.presentID} and use the backing store of the buffer of \textit{A.presentID} as a GL texture
\end{enumerate}
The above will still mostly conform to the EGL specification, indeed quoting section 3.5.1:

\begin{indenter}{0.5cm}
\begin{verbatim}

Client APIs may not be able to respect the 
requested rendering buffer. To determine the 
actual buffer being rendered to by a context, 
call eglQueryContext (see section 3.7.4) u.e., 
in such systems querying EGL_RENDER_BUFFER will 
always return {EGL_TRIPLE_BUFFER_NMK}.  
\end{verbatim}
\end{indenter}


However, the modification to \textit{eglMakeCurrent()} where if one of the surfaces is a triple buffered surface requires that then the both the surfaces are the same has a very, very small potential for error if an application decides to pass a window surface and an offscreen surface as that would result in an error.

\end{indenter}

\section{Bypassing X11}
In the event that we must use X11 and X11 has issues we can somewhat bypass
a poor X11 and/or XComposite implementation as follows. The cross process 
image buffers are XPixmaps. The application will render to the pixmaps 
(by creating the surfaces from the pixmaps via the EGL call 
\textbf{eglCreatePixmapSurface()} and the compositor will display the pixmaps). 
We will need that the implementation supports a means for having a GL texture from an 
XPixmap (such as \textbf{EGL\_KHR\_image\_pixmap}  with \textbf{GL\_OES\_EGL\_image}
for EGL/GLES2 or \textbf{GLX\_EXT\_texture\_from\_pixmap} for GLX/GL). The compositor
will be the only process that has a window (and that window will be fullscreen).
We can implement a subset of the NGL API proposed on top of EGL/X11/GLES2
(or X11/GLX/GL) this way. As a side note, applications should \textit{never, ever} make
a window. Indeed, the X11 API must then be considered a hidden, private
API implementation and not relied upon or used by any application. However, 
we should view this appraoch of making an API on top of X11/EGL/GLES2 (or X11/GLX/GL) 
as a last resort where we have hardware with an X11 implementation and our only option 
is to use that X11 implementation.


\end{document}
